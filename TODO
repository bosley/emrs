

Document this somewhere:


```

  Install action:

      go run cmd/cli/*.go --new-action _actions/logger.go --name logger


  The go file must have `package <name>` 

  Actions should be Global accessable 

  Functions that accept events should be of the signature type:

      func SomeEventHandler(origin string, route[]string, data[] byte) error {

      }

  In the EMRS route:      myModule.SomeEventHandler.more.chunks.etc


    SomeEventHandler will be called, and the route above, aside from the first two elements (myModule, SomeEventHandler),
    will be handed to the handler. so [ a.b.c.d.e =>  a.b(  UUID, [C, D, E], DATA)


    The trailered chunks can be used by the handler function/ submitter as arbitrary
    arguments specific to the submission. They don't need to be used.

```

Document this somewhere:

```
  HTTPS POST format for Submission and CNC endpoints
  
  Header:
    Content-Type: octet-stream
    EMRS-API-Version: <VERSION>           [API Version (not yet utilized)]
    origin: <known asset UUID>            [UUID of reporting asset - must be known to EMRS]
    route <emrs url proc path>            [left blank for CNC]
    token <authentication token>          [MUST be UiKey for CNC AND valid badger voucher, just valid vocucher for submission]
  Body:
    optional: binary data stream
```


Runner

  Need to make GoPath work for the yaegi interpreter such-that the users can import
  the packages within EMRS_HOME/actions on server start-up so we can have more advanced (and clear)
  routing and configuration setup

  Setup runner to not just create a thread for every request. A proper channel/reader setup should be made
  with a mechanism to limit the number of threads, buffering requests while others process.

  Add a timeout context maybe to the execution threads to ensure they don't hog threads


Runner Exports

  Need to figure out what all we want/need to export to the yaegi script that will be running. 

  Add:
    Simple way to log every event. Maybe just a config option,
    and it wont need to be exposed to the exporter

        emrsDbLog("signal.name", datetime, path, data, tags)


    Send to a user's configured twilio account
      emrsAlertSMS("") 

    Send to a user's configured email account
      emrsAlertEmail("")


    While the users could make this in the actions, it would make sense to offer heavier functionalities
    out-of-the-box for the sake of execution speed and adoption.
    

  How will emit/signal work wrt scheduling?

  Do we want to add FS paths to the yaegi environment so the user scripts can do disk operations
  as-per their own configurations?

  Since it has an active environment it really doesn't NEED another DB to share data, but it may be useful if we 
  later add the ability to "reset" the scripts with the server live. Meaning a code change can occur live, and we may want
  some level of data persistence. 




Action Implementations

  Once the runner stuff above is done, I want to add some utility functions to the base `actions` installation

CLI

  Subcommandss are needed. Redo how the current commands work so we can have a better cli. for instance:

      emrs assets --add "moot"
      emrs assets --delete <UUID>
      emrs assets --list

      emrs api --submit <URL> --data <DATA>
      emrs api --cnc <COMMAND> (shutdown, etc)
      emrs api --stat <URL>

      -------------------------
         Password protected
      -------------------------

      emrs server --new-ui-key

      emrs token --count 10 --duration "1h30m"

      -------------------------

      emrs server --web-key   "/path/to/https.key"
      emrs server --web-crt   "/path/to/https.crt"

      emrs (starts server)

      emrs --home "/asa/dd/a2"

APIS

  Submit
    This may be complete aside from any changes that may happen with the interface into the runner module

    Considering adding a "tags" section to the submissions that will be an arbitrary header field of comma
    sep strings the users can use to describe the data
    
  Stat

    Right now this just reports uptime, and is totally public. Its mean to tell if the server
    is still alive (currently the --health) command

  CNC
  
    We might not need more than shutdown until we get everything non-ui tested and running.
    CNC is meant to be for ui submissions to update state



======= Future Ideas

Add turso integration to use a user's turso setup rather than an on-site sqlite db
