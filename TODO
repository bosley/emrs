

Document this somewhere:

```

import emrs modules in the action code with `emrsImport`. It can take any
number of strings, and the "paths" given should be the name of the directory
as it sits in EMRS_HOME/action, so EMRS_HOME/action/example would be imported
by init.go via `emrsImport("example")`.

Within the example directory, there is expected to be a '_emrs.go' file

The prefixed `_` is to allow the emrs.go file to reside in an existing go project
without causing too many problems. 

inside the '_emrs.go' there should exist a global-scope '[]string' defined
as 'Exports` within an `emrs` package that lists the files to be imported by the yaegi interpreter to expand
action definitions.

Each file listed in 'Exports' should be relative to the file that the map exists within,

```

Layout:

```

  Actions
    |--- init.go
    |--- example
          |--- _emrs.go
          |--- myEmrsMod.go
          |--- _subfolder
                  |--- otherMod.go


_emrs.go:

  package emrs    // NOTE: _emrs.go is in emrs package

  var Exports = []string {
      "myEmrsMod.go",
      "_subfolder/otherMod.go"
  }

myEmrsMod.go:

  package example
  
  func Ayy() string { return "lmao" }

_subfolder/otherMod.go

  package example

  func WhatsYorName() string { return "TONY!" }

```

Document this somewhere:

```
  HTTPS POST format for Submission and CNC endpoints
  
  Header:
    Content-Type: octet-stream
    EMRS-API-Version: <VERSION>           [API Version (not yet utilized)]
    origin: <known asset UUID>            [UUID of reporting asset - must be known to EMRS]
    route <emrs url proc path>            [left blank for CNC]
    token <authentication token>          [MUST be UiKey for CNC AND valid badger voucher, just valid vocucher for submission]
  Body:
    optional: binary data stream
```


Runner

  Need to make GoPath work for the yaegi interpreter such-that the users can import
  the packages within EMRS_HOME/actions on server start-up so we can have more advanced (and clear)
  routing and configuration setup

  Setup runner to not just create a thread for every request. A proper channel/reader setup should be made
  with a mechanism to limit the number of threads, buffering requests while others process.

  Add a timeout context maybe to the execution threads to ensure they don't hog threads


Runner Exports

  Need to figure out what all we want/need to export to the yaegi script that will be running. 

  Add:
    Simple way to log every event. Maybe just a config option,
    and it wont need to be exposed to the exporter

        emrsDbLog("signal.name", datetime, path, data, tags)


    Send to a user's configured twilio account
      emrsAlertSMS("") 

    Send to a user's configured email account
      emrsAlertEmail("")


    While the users could make this in the actions, it would make sense to offer heavier functionalities
    out-of-the-box for the sake of execution speed and adoption.
    

  How will emit/signal work wrt scheduling?

  Do we want to add FS paths to the yaegi environment so the user scripts can do disk operations
  as-per their own configurations?

  Since it has an active environment it really doesn't NEED another DB to share data, but it may be useful if we 
  later add the ability to "reset" the scripts with the server live. Meaning a code change can occur live, and we may want
  some level of data persistence. 




Action Implementations

  Once the runner stuff above is done, I want to add some utility functions to the base `actions` installation

CLI

  Subcommandss are needed. Redo how the current commands work so we can have a better cli. for instance:

      emrs assets --add "moot"
      emrs assets --delete <UUID>
      emrs assets --list

      emrs api --submit <URL> --data <DATA>
      emrs api --cnc <COMMAND> (shutdown, etc)
      emrs api --stat <URL>

      -------------------------
         Password protected
      -------------------------

      emrs server --new-ui-key

      emrs token --count 10 --duration "1h30m"

      -------------------------

      emrs server --web-key   "/path/to/https.key"
      emrs server --web-crt   "/path/to/https.crt"

      emrs (starts server)

      emrs --home "/asa/dd/a2"

APIS

  Submit
    This may be complete aside from any changes that may happen with the interface into the runner module

    Considering adding a "tags" section to the submissions that will be an arbitrary header field of comma
    sep strings the users can use to describe the data
    
  Stat

    Right now this just reports uptime, and is totally public. Its mean to tell if the server
    is still alive (currently the --health) command

  CNC
  
    We might not need more than shutdown until we get everything non-ui tested and running.
    CNC is meant to be for ui submissions to update state



======= Future Ideas

Add turso integration to use a user's turso setup rather than an on-site sqlite db
